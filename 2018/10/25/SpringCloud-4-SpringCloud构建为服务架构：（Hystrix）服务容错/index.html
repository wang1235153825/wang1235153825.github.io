<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          SpringCloud-4-SpringCloud构建为服务架构：（Hystrix）服务容错 - 王同学的blog
        
    </title>

    <link rel="canonical" href="http://yoursite-url/2018/10/25/SpringCloud-4-SpringCloud构建为服务架构：（Hystrix）服务容错/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('Demo.png')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/img/signature/BeanTechSign-white.png');
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#SpringCloud" title="SpringCloud">SpringCloud</a>
                            
                        </div>
                        <h1>SpringCloud-4-SpringCloud构建为服务架构：（Hystrix）服务容错</h1>
                        <h2 class="subheading">SpringCloud构建为服务架构：（Hystrix）服务容错</h2>
                        <span class="meta">
                            Posted by 王廷骏 on
                            2018-10-25
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">My Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3><span id="1-hystrix服务降级">1. Hystrix服务降级</span></h3>
<h4><span id="11-引言">1.1 引言</span></h4>
<p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。</p>
<p>针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。</p>
<h4><span id="12-搭建">1.2 搭建</span></h4>
<p>在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括：</p>
<ul>
<li><code>eureka-server</code>工程：服务注册中心，端口：1001</li>
<li><code>eureka-client</code>工程：服务提供者，端口为2001</li>
</ul>
<p>然后我们可以复制一下之前实现的一个服务消费者：<code>eureka-consumer-ribbon</code>，命名为<code>eureka-consumer-ribbon-hystrix</code>。下面我们开始对其进行改在：</p>
<ul>
<li>
<p>第一步：<code>pom.xml</code>的dependencies节点中引入<code>spring-cloud-starter-hystrix</code>依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二步：在应用主类中使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解开启Hystrix的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@EnableCircuitBreaker</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	public RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里我们还可以使用Spring Cloud应用中的@SpringCloudApplication注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public @interface SpringCloudApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第三步：改造服务消费方式，新增<code>ConsumerService</code>类，然后将在<code>Controller</code>中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加<code>@HystrixCommand</code>注解来指定服务降级方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DcController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConsumerService consumerService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/consumer&quot;)</span><br><span class="line">    public String dc() &#123;</span><br><span class="line">        return consumerService.consumer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">    class ConsumerService &#123;</span><br><span class="line"></span><br><span class="line">        @Autowired</span><br><span class="line">        RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">        @HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class="line">        public String consumer() &#123;</span><br><span class="line">            return restTemplate.getForObject(&quot;http://eureka-client/dc&quot;, String.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String fallback() &#123;</span><br><span class="line">            return &quot;fallback&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问<code>localhost:2101/consumer</code>，此时可以获取正常的返回，比如：<code>Services: [eureka-consumer-ribbon-hystrix, eureka-client]</code>。</p>
<p>为了触发服务降级逻辑，我们可以将服务提供者<code>eureka-client</code>的逻辑加一些延迟，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/dc&quot;)</span><br><span class="line">public String dc() throws InterruptedException &#123;</span><br><span class="line">    Thread.sleep(5000L);</span><br><span class="line">    String services = &quot;Services: &quot; + discoveryClient.getServices();</span><br><span class="line">    System.out.println(services);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启<code>eureka-client</code>之后，再尝试访问<code>localhost:2101/consumer</code>，此时我们将获得的返回结果为：<code>fallback</code>。我们从<code>eureka-client</code>的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了<code>fallback</code>。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。</p>
<h3><span id="2hystrix依赖隔离">2.Hystrix依赖隔离</span></h3>
<p>我们已经体验了如何使用<code>@HystrixCommand</code>来为一个依赖资源定义服务降级逻辑。实现方式非常简单，同时对于降级逻辑还能实现一些更加复杂的级联降级等策略。之前对于使用Hystrix来实现服务容错保护时，除了服务降级之外，我们还提到过线程隔离、断路器等功能。那么在本篇中我们就来具体说说线程隔离。</p>
<h4><span id="21-依赖隔离">2.1 依赖隔离</span></h4>
<p>“舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。</p>
<p>通过对依赖服务的线程池隔离实现，可以带来如下优势：</p>
<ul>
<li>应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。</li>
<li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。</li>
<li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。</li>
<li>当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。</li>
<li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li>
<li>除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。</li>
</ul>
<p>总之，通过对依赖服务实现线程池隔离，让我们的应用更加健壮，不会因为个别依赖服务出现问题而引起非相关服务的异常。同时，也使得我们的应用变得更加灵活，可以在不停止服务的情况下，配合动态配置刷新实现性能配置上的调整。</p>
<p>虽然线程池隔离的方案带了如此多的好处，但是很多使用者可能会担心为每一个依赖服务都分配一个线程池是否会过多地增加系统的负载和开销。对于这一点，使用者不用过于担心，因为这些顾虑也是大部分工程师们会考虑到的，Netflix在设计Hystrix的时候，认为线程池上的开销相对于隔离所带来的好处是无法比拟的。同时，Netflix也针对线程池的开销做了相关的测试，以证明和打消Hystrix实现对性能影响的顾虑。</p>
<p>下图是Netflix Hystrix官方提供的一个Hystrix命令的性能监控，该命令以每秒60个请求的速度（QPS）向一个单服务实例进行访问，该服务实例每秒运行的线程数峰值为350个。</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5C%E8%80%97%E6%97%B6.jpg" alt=""></p>
<p>从图中的统计我们可以看到，使用线程池隔离与不使用线程池隔离的耗时差异如下表所示：</p>
<table>
<thead>
<tr>
<th>比较情况</th>
<th>未使用线程池隔离</th>
<th>使用了线程池隔离</th>
<th>耗时差距</th>
</tr>
</thead>
<tbody>
<tr>
<td>中位数</td>
<td>2ms</td>
<td>2ms</td>
<td>2ms</td>
</tr>
<tr>
<td>90百分位</td>
<td>5ms</td>
<td>8ms</td>
<td>3ms</td>
</tr>
<tr>
<td>99百分位</td>
<td>28ms</td>
<td>37ms</td>
<td>9ms</td>
</tr>
</tbody>
</table>
<p>在99%的情况下，使用线程池隔离的延迟有9ms，对于大多数需求来说这样的消耗是微乎其微的，更何况为系统在稳定性和灵活性上所带来的巨大提升。虽然对于大部分的请求我们可以忽略线程池的额外开销，而对于小部分延迟本身就非常小的请求（可能只需要1ms），那么9ms的延迟开销还是非常昂贵的。实际上Hystrix也为此设计了另外的一个解决方案：信号量。</p>
<p>Hystrix中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。在HystrixCommand和HystrixObservableCommand中2处支持信号量的使用：</p>
<ul>
<li>命令执行：如果隔离策略参数execution.isolation.strategy设置为SEMAPHORE，Hystrix会使用信号量替代线程池来控制依赖服务的并发控制。</li>
<li>降级逻辑：当Hystrix尝试降级逻辑时候，它会在调用线程中使用信号量。</li>
</ul>
<p>信号量的默认值为10，我们也可以通过动态刷新配置的方式来控制并发线程的数量。对于信号量大小的估算方法与线程池并发度的估算类似。仅访问内存数据的请求一般耗时在1ms以内，性能可以达到5000rps，这样级别的请求我们可以将信号量设置为1或者2，我们可以按此标准并根据实际请求耗时来设置信号量。</p>
<h4><span id="22-如何使用">2.2 如何使用</span></h4>
<p>说了那么多依赖隔离的好处，那么我们如何使用Hystrix来实现依赖隔离呢？其实，我们在上一篇定义服务降级的时候，已经自动的实现了依赖隔离。</p>
<p>在上一篇的示例中，我们使用了@HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。</p>
<h3><span id="3hystrix断路器">3.Hystrix断路器</span></h3>
<h4><span id="31断路器">3.1断路器</span></h4>
<p>断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。但是，在Hystrix中的断路器除了切断主逻辑的功能之外，还有更复杂的逻辑，下面我们来看看它更为深层次的处理逻辑。</p>
<p>在服务降级中实现的服务降级例子为示例，我们来说说断路器的工作原理。当我们把服务提供者<code>eureka-client</code>中加入了模拟的时间延迟之后，在服务消费端的服务降级逻辑因为hystrix命令调用依赖服务超时，触发了降级逻辑，但是即使这样，受限于Hystrix超时时间的问题，我们的调用依然很有可能产生堆积。</p>
<p>这个时候断路器就会发挥作用，那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是：</p>
<ul>
<li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li>
<li>请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。</li>
<li>错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。</li>
</ul>
<p>那么当断路器打开之后会发生什么呢？我们先来说说断路器未打开之前，对于之前那个示例的情况就是每个请求都会在当hystrix超时之后返回<code>fallback</code>，每个请求时间延迟就是近似hystrix的超时时间，如果设置为5秒，那么每个请求就都要延迟5秒才会返回。当熔断器在10秒内发现请求总数超过20，并且错误百分比超过50%，这个时候熔断器打开。打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级逻辑，这个时候就不会等待5秒之后才返回fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p>
<p>在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p>
<p>通过上面的一系列机制，hystrix的断路器实现了对依赖资源故障的端口、对降级策略的自动切换以及对主逻辑的自动恢复机制。这使得我们的微服务在依赖外部服务或资源的时候得到了非常好的保护，同时对于一些具备降级逻辑的业务需求可以实现自动化的切换与恢复，相比于设置开关由监控和运维来进行切换的传统实现方式显得更为智能和高效。</p>
<h4><span id="32使用断路器">3.2使用断路器</span></h4>
<p>使用断路器也非常简单，Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feign.hystrix.enabled=true</span><br></pre></td></tr></table></figure>
<p>然后在方法类上加上注解<code>@FeignClient(value = &quot;service-hi&quot;,fallback = fallback方法类.class)</code></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;service-hi&quot;,fallback = SchedualServiceHiHystric.class)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/hi&quot;,method = RequestMethod.GET)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value = &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SchedualServiceHiHystric implements SchedualServiceHi &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHiFromClientOne(String name) &#123;</span><br><span class="line">        return &quot;sorry &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="4hystrix监控面板">4.Hystrix监控面板</span></h3>
<p>在上面我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。</p>
<p>下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括：</p>
<ul>
<li>eureka-server：服务注册中心</li>
<li>eureka-client：服务提供者</li>
<li>eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者</li>
</ul>
<p>由于eureka-consumer-ribbon-hystrix项目中的<code>/consumer</code>接口实现使用了<code>@HystrixCommand</code>修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上面中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。</p>
<h4><span id="41-搭建">4.1 搭建</span></h4>
<p>在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步：</p>
<ul>
<li>
<p>创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。</p>
</li>
<li>
<p>编辑pom.xml，具体依赖内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">	&lt;relativePath /&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为应用主类加上<code>@EnableHystrixDashboard</code>，启用Hystrix Dashboard功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableHystrixDashboard</span><br><span class="line">@SpringCloudApplication</span><br><span class="line">public class HystrixDashboardApplication &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(HystrixDashboardApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据实际情况修改<code>application.properties</code>配置文件，比如：选择一个未被占用的端口等，此步非必须。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=hystrix-dashboard</span><br><span class="line">server.port=1301</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：<code>http://localhost:1301/hystrix</code>，我们可以看到如下页面：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5Chystrix.jpg" alt=""></p>
<p>这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：</p>
<ul>
<li>
<p>默认的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream</code>开启，实现对默认集群的监控。</p>
</li>
<li>
<p>指定的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</code>开启，实现对clusterName集群的监控。</p>
</li>
<li>
<p>单体应用的监控：通过URL<code>http://hystrix-app:port/hystrix.stream</code>开启，实现对具体某个服务实例的监控。</p>
</li>
</ul>
<p>前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。</p>
<p>既然Hystrix Dashboard监控单实例节点需要通过访问实例的<code>/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步：</p>
<ul>
<li>
<p>在服务实例(eureka-consumer-ribbon-hystrix)<code>pom.xml</code>中的<code>dependencies</code>节点中新增<code>spring-boot-starter-actuator</code>监控模块以开启监控相关的端点，并确保已经引入断路器的依赖<code>spring-cloud-starter-hystrix</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>确保在服务实例的主类中已经使用<code>@EnableCircuitBreaker</code>或<code>@EnableHystrix</code>注解，开启了断路器功能。在启动服务时，我们可以看到一下输出：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5C1540537713(1).jpg" alt=""></p>
<p>这个信息表明我们的consumer工程目前已经具备了/hystrix.stream接口，我们可以直接访问这个接口了。<strong>但是这里有一个细节需要注意：要访问/hystrix.stream接口，得先访问consumer工程中的任意一个其他接口，否则如果直接访问/hystrix.stream接口的话，会打印出一连串的ping: ping: …。</strong> OK，我先访问consumer中的任意一个其他接口，然后在访问/hystrix.stream接口，访问地址如下：<a href="http://localhost:9000/hystrix.stream" target="_blank" rel="noopener">http://localhost:2101/hystrix.stream</a>，访问结果如下：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5C1540537879(1).jpg" alt=""></p>
<p>我们看到返回结果是一段json数据，单纯的查看json数据，我们很难分析出结果，所以，我们要在Hystrix仪表盘中来查看这一段json，在hystrix仪表盘中输入监控地址，如下：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5C1540537922(1).jpg" alt=""></p>
<p>然后点击Monitor Stream按钮，我们就可以看到监控画面了，如下：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5C1540538077(1).jpg" alt=""></p>
</li>
</ul>
<p>在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数：</p>
<ul>
<li><code>Delay</code>：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。</li>
<li><code>Title</code>：该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。</li>
</ul>
<p>回到监控页面，我们来详细说说其中各元素的具体含义：</p>
<ul>
<li>
<p>我们可以在监控信息的左上部分找到两个重要的图形信息：一个实心圆和一条曲线。</p>
<ul>
<li>
<p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。</p>
</li>
<li>
<p>曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势。</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5Cspring-cloud-starter-dalston-5-1-3.png" alt=""></p>
</li>
</ul>
</li>
<li>
<p>其他一些数量指标如下图所示：</p>
</li>
</ul>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5Cspring-cloud-starter-dalston-5-1-4.png" alt=""></p>
<h3><span id="5-hystrix监控数据聚合">5. Hystrix监控数据聚合</span></h3>
<p>上面我们介绍了使用Hystrix Dashboard来展示Hystrix用于熔断的各项度量指标。通过Hystrix Dashboard，我们可以方便的查看服务实例的综合情况，比如：服务调用次数、服务调用延迟等。但是仅通过Hystrix Dashboard我们只能实现对服务当个实例的数据展现，在生产环境我们的服务是肯定需要做高可用的，那么对于多实例的情况，我们就需要将这些度量指标数据进行聚合。下面，在本篇中，我们就来介绍一下另外一个工具：Turbine。</p>
<h4><span id="51-准备工作">5.1 准备工作</span></h4>
<p>在开始使用Turbine之前，我们先回顾一下上一篇中实现的架构，如下图所示：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5Cspring-cloud-starter-dalston-5-2-1.png" alt=""></p>
<p>其中，我们构建的内容包括：</p>
<ul>
<li>eureka-server：服务注册中心</li>
<li>eureka-client：服务提供者</li>
<li>eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者</li>
<li>hystrix-dashboard：用于展示<code>eureka-consumer-ribbon-hystrix</code>服务的Hystrix数据</li>
</ul>
<p>下面，我们将在上述架构基础上，引入Turbine来对服务的Hystrix数据进行聚合展示。这里我们将分别介绍两种聚合方式。</p>
<h4><span id="52-通过http收集聚合">5.2 通过HTTP收集聚合</span></h4>
<p>具体实现步骤如下：</p>
<ul>
<li>
<p>创建一个标准的Spring Boot工程，命名为：turbine。</p>
</li>
<li>
<p>编辑pom.xml，具体依赖内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">	&lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建应用主类<code>TurbineApplication</code>，并使用<code>@EnableTurbine</code>注解开启Turbine。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@EnableTurbine</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class TurbineApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(TurbineApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>application.properties</code>加入eureka和turbine的相关配置，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=turbine</span><br><span class="line"></span><br><span class="line">server.port=8989</span><br><span class="line">management.port=8990</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/</span><br><span class="line"></span><br><span class="line">turbine.app-config=eureka-consumer-ribbon-hystrix</span><br><span class="line">turbine.cluster-name-expression=&quot;default&quot;</span><br><span class="line">turbine.combine-host-port=true</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<ul>
<li><code>turbine.app-config</code>参数指定了需要收集监控信息的服务名；</li>
<li><code>turbine.cluster-name-expression</code> 参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过<code>cluster</code>参数来指定；</li>
<li><code>turbine.combine-host-port</code>参数设置为<code>true</code>，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。</li>
</ul>
</li>
</ul>
<p>在完成了上面的内容构建之后，我们来体验一下Turbine对集群的监控能力。分别启动<code>eureka-server</code>、<code>eureka-client</code>、<code>eureka-consumer-ribbon-hystrix</code>、<code>turbine</code>以及<code>hystrix-dashboard。访问Hystrix Dashboard，并开启对</code><a href="http://localhost:8989/turbine.stream%60%E7%9A%84%E7%9B%91%E6%8E%A7%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E7%9C%8B%E5%88%B0%E9%92%88%E5%AF%B9%E6%9C%8D%E5%8A%A1%60eureka-consumer-ribbon-hystrix%60%E7%9A%84%E8%81%9A%E5%90%88%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E3%80%82" target="_blank" rel="noopener">http://localhost:8989/turbine.stream</a>的监控，可以看到针对服务eureka-consumer-ribbon-hystrix的聚合监控数据。</p>
<p>而此时的架构如下图所示：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5Cspring-cloud-starter-dalston-5-2-2.png" alt=""></p>
<h4><span id="54-通过消息代理收集聚合">5.4 通过消息代理收集聚合</span></h4>
<p>Spring Cloud在封装Turbine的时候，还实现了基于消息代理的收集实现。所以，我们可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步的获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。通过引入消息代理，我们的Turbine和Hystrix Dashoard实现的监控架构可以改成如下图所示的结构：</p>
<p><img src="E:%5Chexo-wtj%5Csource_posts%5CSpringCloud-4-SpringCloud%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9A(Hystrix)%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%5Cspring-cloud-starter-dalston-5-2-3.png" alt=""></p>
<p>从图中我们可以看到，这里多了一个重要元素：RabbitMQ。对于RabbitMQ的安装与基本时候我们可以查看之前的<a href="http://blog.didispace.com/spring-boot-rabbitmq/" target="_blank" rel="noopener">《Spring Boot中使用RabbitMQ》</a>一文，这里不做过多的说明。下面，我们可以来构建一个新的应用来实现基于消息代理的Turbine聚合服务，具体步骤如下：</p>
<ul>
<li>
<p>创建一个标准的Spring Boot工程，命名为：<code>turbine-amqp</code>。</p>
</li>
<li>
<p>编辑<code>pom.xml</code>，具体依赖内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">	&lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-turbine-amqp&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到这里主要引入了<code>spring-cloud-starter-turbine-amqp</code>依赖，它实际上就是包装了<code>spring-cloud-starter-turbine-stream</code>和<code>pring-cloud-starter-stream-rabbit</code>。</p>
<p><strong>注意：这里我们需要使用Java 8来运行</strong></p>
<ul>
<li>
<p>在应用主类中使用<code>@EnableTurbineStream</code>注解来启用Turbine Stream的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@EnableTurbineStream</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class TurbineApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(TurbineApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置<code>application.properties</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=turbine-amqp</span><br><span class="line"></span><br><span class="line">server.port=8989</span><br><span class="line">management.port=8990</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于Turbine的配置已经完成了，下面我们需要对服务消费者<code>eureka-consumer-ribbon-hystrix</code>做一些修改，使其监控信息能够输出到RabbitMQ上。这个修改也非常简单，只需要在<code>pom.xml</code>中增加对<code>spring-cloud-netflix-hystrix-amqp</code>依赖，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>在完成了上面的配置之后，我们可以继续之前的所有项目（除turbine以外），并通过Hystrix Dashboard开启对<code>http://localhost:8989/turbine.stream</code>的监控，我们可以获得如之前实现的同样效果，只是这里我们的监控信息收集时是通过了消息代理异步实现的。</p>
<p>文章整理摘自<a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">翟永超的spring cloud教程</a></p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2018/10/24/SpringCloud-3.SpringCloud构建微服务架构：分布式配置中心/" data-toggle="tooltip" data-placement="top" title="SpringCloud-3.SpringCloud构建微服务架构：分布式配置中心">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. Hystrix服务降级</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.1 引言</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">1.2 搭建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2.Hystrix依赖隔离</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">2.1 依赖隔离</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.2 如何使用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3.Hystrix断路器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">3.1断路器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">3.2使用断路器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4.Hystrix监控面板</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">4.1 搭建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. Hystrix监控数据聚合</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">5.1 准备工作</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">5.2 通过HTTP收集聚合</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">5.4 通过消息代理收集聚合</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#SpringCloud" title="SpringCloud">SpringCloud</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "your-disqus-ID";
    var disqus_identifier = "http://yoursite-url/2018/10/25/SpringCloud-4-SpringCloud构建为服务架构：（Hystrix）服务容错/";
    var disqus_url = "http://yoursite-url/2018/10/25/SpringCloud-4-SpringCloud构建为服务架构：（Hystrix）服务容错/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 王廷骏 2018 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite-url/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite-url/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
